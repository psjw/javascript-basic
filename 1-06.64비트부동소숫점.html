<!DOCTYPE html>
<html>

<head>
    <title>Document</title>
</head>

<body>
    <script>
        let x = 0.1 + 0.2;
        console.log(x); //예측값 : 0.3
        // 실제 : 0.30000000000000004
        // 자바와 같은 경우 int, long과 같은 여러 선언자를 써서 해결
        // 64비트 부동소수점

        console.log(1 / 2); // 0.5 유한소수
        console.log(2 / 3); // 0.666666... 무한소수

        //0.1 = 1/10 -> 2진법 표현 2의 거듭제곱이 안됨: 무한소수
        //0.2 = 1/5  -> 2진법 표현 2의 거듭제곱이 안됨 

        console.log((0.1).toString());

        console.log((0.1).toString(2)); //2진수로 변환
        // 0.0001100110011001100110011001100110011001100110011001101
        // 64비트 부동소수점
        // 64비트를 넘는 소숫점 -> 65번째 비트 반올림하여 64비트로 표현
        // 첫번째 1비트 - 양수 0, 음수 1
        // 11비트 - 지수부 : 2^(n-1)-1 + m (n:몇비트 사용하는가? 현재 11,m: 1.이 될때까지 .을 이동함-> 오른쪽 -, 왼쪽 + -> 현재 : 오른쪽 4)
        //                   2^(10)-1 + m  = 1024 - 1 - 4 = 1019
        // 52비트 - 가수부
        // 100110011001100110011001100110011001100110011001101
        // 실제 값은 52비트에 저장

        //소숫점 1~2자리인 경우는 문제 발생 소지가 낮음
        console.log((1019).toString(2));
        //1111111011
        //앞에 0을 채움 -> 01111111011
        //가수부 1.xxx에서 1. 뒷부분 채움 빈자리는 0으로 채움

        console.log((0.2).toString(2));
        //0.001100110011001100110011001100110011001100110011001101
        //1비트 - 9
        //11비트 - 
        //2^10-1 - 3 = 1020
        console.log((1020).toString(2));
        //1111111100
        //01111111100

        //0.2 ==> 0.001100110011001100110011001100110011001100110011001101
        //0.1 ==> 0.0001100110011001100110011001100110011001100110011001101
        //        0.0100110011001100110011001100110011001100110011001100111


        console.log(parseInt('0100110011001100110011001100110011001100110011001100111', 2) * Math.pow(2, -55));
        //외부라이브러리 사용
        //BigNumber.js
        //Big.js
        //Decimal.js

        let x2 = 9999999999999999; //10000000000000000
        console.log(x2);
        //9007199254740991
        console.log(Number.MAX_SAFE_INTEGER); //안정적인 최대 인티저값
    </script>
</body>

</html>